### Ошибка 1 - ошибка границы цикла (off-by-one)
Место: src/library.py, функция run_simulation

Симптом:
При запуске симуляции с steps=1 не выполняется ни одного шага (лог пустой).

Как воспроизвести:
Запустить:
`python -c "from src.library import run_simulation; run_simulation(steps=1, seed=42)"`

Отладка:
Установлен breakpoint на строке цикла `for step in range(1, steps):`.
В отладчике видно, что `steps = 1`, а диапазон `range(1, steps)` превращается в `range(1, 1)` (пустой), поэтому тело цикла не выполняется.
Call Stack показывает остановку в `run_simulation` (вызов из debug_run.py).

Причина:
Неверная граница диапазона: используется `range(1, steps)`, который не включает последний шаг.

Исправление:
Заменено на:
`for step in range(1, steps + 1):`

Проверка:
Повторный запуск с `steps=1` выводит `Шаг 1` и выполняет событие.

Доказательства:

**Точка останова в цикле симуляции:**

![Breakpoint](assets/lab5/bug1_breakpoint_loop.png)

**Кадр стека и значения локальных переменных:**

![Call Stack и Locals](assets/lab5/bug1_callstack_and_locals.png)


### Ошибка 2 - сравнение через is вместо ==
Место: src/library.py, метод find_by_genre

Симптом:
Поиск по жанру не находит книги, хотя в библиотеке присутствует книга с данным жанром.

Как воспроизвести:
Создать библиотеку, добавить книгу с жанром "роман" и выполнить поиск через метод `find_by_genre("роман")`.

Отладка:
Установлен breakpoint в методе `find_by_genre` на строке с условием фильтрации.
В отладчике видно, что значение переменной `genre` равно `"роман"`, однако сравнение `book.genre.lower() is genre.lower()` возвращает False, из-за чего книга не попадает в результирующую коллекцию.
Call Stack показывает остановку в методе `find_by_genre` (вызов из debug_run.py).

Причина:
Использовано сравнение строк через оператор `is`, который проверяет идентичность объектов в памяти, а не равенство их значений.
Метод `lower()` создаёт новые объекты строк, поэтому сравнение через `is` почти всегда возвращает False.

Исправление:
Заменено на сравнение через оператор `==`:
`book.genre.lower() == genre.lower()`

Проверка:
После исправления поиск по жанру возвращает корректное количество книг(книга с жанром "роман" успешно находится).

Доказательства:

**Точка останова в методе find_by_genre:**

![Breakpoint](assets/lab5/bug2_breakpoint_find_by_genre.png)

**Кадр стека и значения локальных переменных:**

![Call Stack и Locals](assets/lab5/bug2_callstack_and_locals.png)


### Ошибка 3 - неверное логическое условие (проверка пустой библиотеки не срабатывает)
Место: src/library.py, функция remove_book_event

Симптом:
При попытке удалить книгу из пустой библиотеки программа падает с исключением IndexError,
вместо того чтобы вывести сообщение о пустой библиотеке.

Как воспроизвести:
Создать пустую библиотеку и вызвать `remove_book_event(library, rng)`.
(При запуске сценария удаления на пустой коллекции возникает падение.)

Отладка:
Установлен breakpoint на условии проверки пустой библиотеки.
В отладчике видно, что библиотека пуста (длина коллекции книг равна 0), но из-за неверного условия `len(library.books) < 0` проверка не срабатывает и выполнение идёт дальше.
После этого происходит вызов удаления случайной книги из пустой коллекции, что приводит к IndexError.
Call Stack показывает цепочку вызовов до места исключения.

Причина:
Использовано неверное логическое условие проверки пустой коллекции:
`len(library.books) < 0` никогда не бывает True, поэтому защитный `return` не выполняется.

Исправление:
Заменено на корректное условие:
`if len(library.books) == 0:`

Проверка:
После исправления при пустой библиотеке выводится
"[удаление] Библиотека пуста, нечего удалять", исключение не возникает.

Доказательства:

**Точка останова на неверном условии:**

![Breakpoint](assets/lab5/bug3_breakpoint_remove_guard.png)

**Кадр стека и значения локальных переменных в момент исключения:**

![Call Stack и Locals](assets/lab5/bug3_exception_callstack_and_locals.png)

**Исключения:**

![Traceback](assets/lab5/bug3_traceback_terminal.png)


### Ошибка 4 - использование изменяемого значения по умолчанию (mutable default)
Место: src/library.py, класс BookCollection, метод __init__

Симптом:
Два разных объекта BookCollection() используют один и тот же список книг.
Добавление книги в c1 приводит к тому, что len(c2) тоже становится 1.

Как воспроизвести:
Создать два объекта `BookCollection()` и добавить книгу только в одну коллекцию:

c1 = BookCollection()
c2 = BookCollection()
c1.add(book)

После этого `len(c2)` также становится равным 1.

Отладка:
Установлен breakpoint в BookCollection.__init__.
В отладчике в Locals видно, что параметр books использует значение по умолчанию `[]`.
Call Stack показывает вызов __init__ из debug_run.py.
Из-за mutable default один и тот же список переиспользуется между объектами.

Причина:
Использовано изменяемое значение по умолчанию `[]` в аргументах функции.
Оно создаётся один раз и переиспользуется всеми вызовами конструктора.

Исправление:
Значение по умолчанию заменено на `None`, новый список создаётся внутри конструктора:
`self.books = list(books) if books is not None else []`

Проверка:
После исправления len(c2) остаётся 0, а `c1.books is c2.books` становится False.

Доказательства:

**Точка останова в BookCollection.__init__:**
![Breakpoint](assets/lab5/bug4_breakpoint_init_mutable.png)

**Кадр стека и значения локальных переменных:**
![Call Stack и Locals](assets/lab5/bug4_callstack_and_locals.png)


### Ошибка 5 - перепутанные аргументы при создании объекта
Место: src/library.py, функция random_book

Симптом:
При выполнении поиска по жанру программа аварийно завершалась с ошибкой `AttributeError: 'int' object has no attribute 'lower'`, хотя в библиотеке есть книги.

Как воспроизвести:
Добавить одну случайную книгу и выполнить поиск по жанру.

Отладка:
Breakpoint поставлен в `Library.find_by_genre`. В стеке видно, что `book.genre` имеет тип `int`, и поэтому вызов `lower()` падает.
Следующий уровень показывает создание книги в `random_book`.
В вызове конструктора `DigitalBook` аргументы передаются как `(title, author, genre, year, isbn, ...)`, из-за чего поля `genre` и `year` перепутаны.

Причина:
Неверный порядок аргументов приводит к тому, что поле `genre` заполняется числом, а `year` - строкой.

Исправление:
Аргументы выстроены в нужном порядке:
`return DigitalBook(title, author, year, genre, isbn, file_format, file_size)`

Проверка:
После поправки поиск по жанру завершался успешно.

Доказательства:

**Точка останова в random_book (цикл генерации цифровой книги):**
![Breakpoint](assets/lab5/bug5_breakpoint_random_book.png)

**Кадр стека и локальные переменные:**
![Call Stack и Locals](assets/lab5/bug5_callstack_and_locals.png)

**Исключения:**
![Traceback](assets/lab5/bug5_traceback_terminal.png)
