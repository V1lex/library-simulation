### Ошибка 1 - ошибка границы цикла (off-by-one)
Место: src/library.py, функция run_simulation

Симптом:
При запуске симуляции с steps=1 не выполняется ни одного шага (лог пустой).

Как воспроизвести:
Запустить:
`python -c "from src.library import run_simulation; run_simulation(steps=1, seed=42)"`


Отладка:
Установлен breakpoint на строке цикла `for step in range(1, steps):`.
В отладчике видно, что `steps = 1`, а диапазон `range(1, steps)` превращается в `range(1, 1)` (пустой), поэтому тело цикла не выполняется.
Call Stack показывает остановку в `run_simulation` (вызов из debug_run.py).

Причина:
Неверная граница диапазона: используется `range(1, steps)`, который не включает последний шаг.

Исправление:
Заменено на:
`for step in range(1, steps + 1):`

Проверка:
Повторный запуск с `steps=1` выводит `Шаг 1` и выполняет событие.

Доказательства:

**Точка останова в цикле симуляции:**

![Breakpoint](assets/lab5/bug1_breakpoint_loop.png)

**Кадр стека и значения локальных переменных:**

![Call Stack и Locals](assets/lab5/bug1_callstack_and_locals.png)


### Ошибка 2 - сравнение через is вместо ==
Место: src/library.py, метод find_by_genre

Симптом:
Поиск по жанру не находит книги, хотя в библиотеке присутствует книга с данным жанром.

Как воспроизвести:
Создать библиотеку, добавить книгу с жанром "роман" и выполнить поиск через метод `find_by_genre("роман")`.

Отладка:
Установлен breakpoint в методе `find_by_genre` на строке с условием фильтрации.
В отладчике видно, что значение переменной `genre` равно `"роман"`,
однако сравнение `book.genre.lower() is genre.lower()` возвращает False, из-за чего книга не попадает в результирующую коллекцию.
Call Stack показывает остановку в методе `find_by_genre` (вызов из debug_run.py).

Причина:
Использовано сравнение строк через оператор `is`, который проверяет идентичность объектов в памяти, а не равенство их значений.
Метод `lower()` создаёт новые объекты строк, поэтому сравнение через `is` почти всегда возвращает False.

Исправление:
Заменено на сравнение через оператор `==`:
`book.genre.lower() == genre.lower()`

Проверка:
После исправления поиск по жанру возвращает корректное количество книг
(книга с жанром "роман" успешно находится).

Доказательства:

**Точка останова в методе find_by_genre:**

![Breakpoint](assets/lab5/bug2_breakpoint_find_by_genre.png)

**Кадр стека и значения локальных переменных:**

![Call Stack и Locals](assets/lab5/bug2_callstack_and_locals.png)


### Ошибка 3 - неверное логическое условие (проверка пустой библиотеки не срабатывает)
Место: src/library.py, функция remove_book_event

Симптом:
При попытке удалить книгу из пустой библиотеки программа падает с исключением IndexError,
вместо того чтобы вывести сообщение о пустой библиотеке.

Как воспроизвести:
Создать пустую библиотеку и вызвать `remove_book_event(library, rng)`.
(При запуске сценария удаления на пустой коллекции возникает падение.)

Отладка:
Установлен breakpoint на условии проверки пустой библиотеки.
В отладчике видно, что библиотека пуста (длина коллекции книг равна 0),
но из-за неверного условия `len(library.books) < 0` проверка не срабатывает и выполнение идёт дальше.
После этого происходит вызов удаления случайной книги из пустой коллекции, что приводит к IndexError.
Call Stack показывает цепочку вызовов до места исключения.

Причина:
Использовано неверное логическое условие проверки пустой коллекции:
`len(library.books) < 0` никогда не бывает True, поэтому защитный `return` не выполняется.

Исправление:
Заменено на корректное условие:
`if len(library.books) == 0:`

Проверка:
После исправления при пустой библиотеке выводится
"[удаление] Библиотека пуста, нечего удалять", исключение не возникает.
Тесты `pytest` проходят.

Доказательства:

**Точка останова на неверном условии:**

![Breakpoint](assets/lab5/bug3_breakpoint_remove_guard.png)

**Кадр стека и значения локальных переменных в момент исключения:**

![Call Stack и Locals](assets/lab5/bug3_exception_callstack_and_locals.png)

**Traceback исключения в терминале:**

![Traceback](assets/lab5/bug3_traceback_terminal.png)
